#include "stdafx.h"
#include "dsp_keepalive.h"

#define M_PI 3.14159265358979323846

DECLARE_COMPONENT_VERSION("Keep Alive", "0.0.1", "Keep Alive DSP component 0.0.1\nby withmorten");
VALIDATE_COMPONENT_FILENAME("foo_dsp_keepalive.dll");

void DspKeepAlive::on_endofplayback(abort_callback&) { }
void DspKeepAlive::on_endoftrack(abort_callback&) { }
void DspKeepAlive::flush() { }
double DspKeepAlive::get_latency() { return 0; }
bool DspKeepAlive::need_track_change_mark() { return false; }

DspKeepAlive::DspKeepAlive(dsp_preset const& in) {
}

GUID DspKeepAlive::g_get_guid() {
	static const GUID guid =
	{ 0x2a8f9c14, 0x6b2e, 0x4d73, { 0x9a, 0x15, 0x7c, 0x8e, 0x4f, 0x91, 0x2b, 0x56 } };
	return guid;
}

void DspKeepAlive::g_get_name(pfc::string_base& p_out) {
	p_out = "Keep Alive";
}

bool DspKeepAlive::g_have_config_popup() { return false; }


bool DspKeepAlive::on_chunk(audio_chunk* chunk, abort_callback&) {
    // generated by claude
	// Get basic audio properties
    t_size sample_count = chunk->get_sample_count();
    unsigned channels = chunk->get_channels();
    unsigned sample_rate = chunk->get_srate();
    audio_sample* samples = chunk->get_data();

    // High frequency tone parameters
    const double tone_frequency = 22049.0; // Hz - above most human hearing
    const audio_sample tone_amplitude = 0.0001f; // Very quiet amplitude

    // Static phase accumulator to maintain continuity between chunks
    static double phase = 0.0;

    // Calculate phase increment per sample
    const double phase_increment = (tone_frequency * 2.0 * M_PI) / sample_rate;

    // Add the tone to all channels
    for (t_size i = 0; i < sample_count; i++) {
        // Generate sine wave sample
        audio_sample tone_sample = (audio_sample)(sin(phase) * tone_amplitude);

        // Add tone to all channels
        for (unsigned ch = 0; ch < channels; ch++) {
            samples[i * channels + ch] += tone_sample;
        }

        // Advance phase
        phase += phase_increment;

        // Keep phase in reasonable range to avoid precision issues
        if (phase >= 2.0 * M_PI) {
            phase -= 2.0 * M_PI;
        }
    }

    return true; // Continue processing
}

bool DspKeepAlive::g_get_default_preset(dsp_preset& p_out) {
    dsp_preset_builder builder;
    builder.finish(g_get_guid(), p_out);
	return true;
}

void DspKeepAlive::g_show_config_popup(const dsp_preset& p_data, HWND p_parent, dsp_preset_edit_callback& p_callback) {
}

static dsp_factory_t<DspKeepAlive> g_dsp_keepalive_factory;
