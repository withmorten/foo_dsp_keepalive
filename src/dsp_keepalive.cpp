#include "stdafx.h"
#include "dsp_keepalive.h"
#include "dsp_keepalive_dialog.h"

#define M_PI 3.14159265358979323846

#define DEFAULT_AMPLITUDE 1

DECLARE_COMPONENT_VERSION("Keep Alive", "0.0.1", "Keep Alive DSP component 0.0.1\nby withmorten");
VALIDATE_COMPONENT_FILENAME("foo_dsp_keepalive.dll");

void dsp_keepalive_params::set_amplitude(int amplitude) {
    this->amplitude_source = amplitude;
	this->amplitude = (double)amplitude_source / (double)10000;
}

void DspKeepAlive::on_endofplayback(abort_callback&) { }
void DspKeepAlive::on_endoftrack(abort_callback&) { }
void DspKeepAlive::flush() { }
double DspKeepAlive::get_latency() { return 0; }
bool DspKeepAlive::need_track_change_mark() { return false; }

DspKeepAlive::DspKeepAlive(dsp_preset const &in) : m_params{ dsp_keepalive_params(DEFAULT_AMPLITUDE) } {
	parse_preset(m_params, in);
}

GUID DspKeepAlive::g_get_guid() {
	static const GUID guid =
	{ 0x2a8f9c14, 0x6b2e, 0x4d73, { 0x9a, 0x15, 0x7c, 0x8e, 0x4f, 0x91, 0x2b, 0x56 } };
	return guid;
}

void DspKeepAlive::g_get_name(pfc::string_base& p_out) {
	p_out = "Keep Alive";
}

bool DspKeepAlive::g_have_config_popup() { return true; }


bool DspKeepAlive::on_chunk(audio_chunk* chunk, abort_callback&) {
    // generated by claude
	// Get basic audio properties
    t_size sample_count = chunk->get_sample_count();
    unsigned channels = chunk->get_channels();
    unsigned sample_rate = chunk->get_srate();
    audio_sample* samples = chunk->get_data();

    // High frequency tone parameters
    const double tone_frequency = 22049.0; // Hz - above most human hearing
    const audio_sample tone_amplitude = m_params.amplitude;

    // Static phase accumulator to maintain continuity between chunks
    static double phase = 0.0;

    // Calculate phase increment per sample
    const double phase_increment = (tone_frequency * 2.0 * M_PI) / sample_rate;

    // Add the tone to all channels
    for (t_size i = 0; i < sample_count; i++) {
        // Generate sine wave sample
        audio_sample tone_sample = (audio_sample)(sin(phase) * tone_amplitude);

        // Add tone to all channels
        for (unsigned ch = 0; ch < channels; ch++) {
            samples[i * channels + ch] += tone_sample;
        }

        // Advance phase
        phase += phase_increment;

        // Keep phase in reasonable range to avoid precision issues
        if (phase >= 2.0 * M_PI) {
            phase -= 2.0 * M_PI;
        }
    }

    return true; // Continue processing
}

bool DspKeepAlive::g_get_default_preset(dsp_preset& p_out) {
    make_preset(dsp_keepalive_params(DEFAULT_AMPLITUDE), p_out);
	return true;
}

void DspKeepAlive::make_preset(dsp_keepalive_params params, dsp_preset& out) {
	dsp_preset_builder builder;
	builder << params.amplitude_source;
	builder.finish(g_get_guid(), out);
}

void DspKeepAlive::parse_preset(dsp_keepalive_params& params, const dsp_preset& in) {
	try {
		dsp_preset_parser parser(in);
        int amplitude;
		parser >> amplitude;
		params.set_amplitude(amplitude);
	}
	catch (exception_io_data) {
		params.set_amplitude(DEFAULT_AMPLITUDE);
	}
}

void DspKeepAlive::g_show_config_popup(const dsp_preset& p_data, HWND p_parent, dsp_preset_edit_callback& p_callback) {
    ::RunDSPConfigPopup(p_data, p_parent, p_callback);
}

static void RunDSPConfigPopup(const dsp_preset& p_data, HWND p_parent, dsp_preset_edit_callback& p_callback) {
	DspKeepAliveDialog popup(p_data, p_callback);
	if (popup.DoModal(p_parent) != IDOK) {
		p_callback.on_preset_changed(p_data);
	}
}

static dsp_factory_t<DspKeepAlive> g_dsp_keepalive_factory;
